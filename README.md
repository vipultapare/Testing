# Testing
This is study Material for testing

<h1>What is the Difference between Bug, error, and Failure</h1>

<h2>Bug</h2>
<p>In software testing, a bug is the informal name of defects, which means that software or application is not working as per the requirement. When we have some coding error, it leads a program to its breakdown, which is known as a bug. The test engineers use the terminology Bug. If a QA (Quality Analyst) detects a bug, they can reproduce the bug and record it with the help of the bug report template.</p>

<h2>Defect</h2>
<p>When the application is not working as per the requirement is known as a defect. It is specified as the aberration from the actual and expected result of the application or software. In other words, we can say that the bug announced by the programmer and inside the code is called a Defect.</p>

<h2>Error</h2>
<p>The Problem in code leads to errors, which means that a mistake can occur due to the developer's coding error as the developer misunderstood the requirement or the requirement was not defined correctly. The developers use the term error.</p>

<h2>failure</h2>
<p>Many defects lead to the software's failure, which means that a loss specifies a fatal issue in the software/ application or in its module, which makes the system unresponsive or broken. In other words, we can say that if an end-user detects an issue in the product, then that particular issue is called a failure. Possibilities are there one defect that might lead to one failure or several failures. For example, in a bank application, if the Amount Transfer module is not working for end-users when the end-user tries to transfer money, the submit button is not working. Hence, this is a failure.</p>

<hr />

<h1>Difference Between Testing and Debugging</h1>
<h2>Testing</h2>
<p>Software testing is a process of identifying defects in the software product. It is performed to validate the behavior of the software or the application compared to requirements. In other words, we can say that the testing is a collection of techniques to determine the accuracy of the application under the predefined specification but, it cannot identify all the defects of the software. Each software or application needs to be tested before delivering to the clients and checks whether the particular software or the application is working fine as per the given requirements.</p>
<h2>Debugging</h2>
<p>As opposed to Testing, Debugging is the action that the development team or a developer implements after receiving the test report related to the bugs in the software from the testing team.In the software development process, debugging includes detecting and modifying code errors in a software program.In the debugging process, the developer needs to identify the reason behind the particular bug or defect, which is carried out by analyzing the coding rigorously.The developer changes the code and then rechecks whether the defect has been deleted whenever the bug or error is found. Once the debugging is successfully finished, the application is again sent back to the test engineers, who remain in the process of testing. The debugging process allows us an earlier finding of an error and makes software development stress-free and easy.
Now, based on features and techniques of practice, we can distinguish between Testing and Debugging.</p>

<hr />

<h1>HLD and LLD</h1>
<h2>HLD</h2>
<ul>
  <li>High Level Design</li>
  <li>It is the general system design, which means it signifies the overall system design.</li>
  <li>HLD is also called a System or macro-level design.</li>
  <li>Solution Architect prepares the High-Level Design.</li>
  <li>It is developed first in sequential order, which implies that the HLD is created before the LLD.</li>
  <li>It is used by management, program, and solution teams.</li>
  <li>The high-level design is necessary to understand the flow across several system objects.</li>
  <li>The input measure in high-level design is SRS (Software Requirement Specification).</li>
  <li>The output measures in the HLD are functional design, database design, and review record.</li>
</ul>

<h2>LLD</h2>
<ul>
  <li>Low Level Design</li>
  <li>It is like describing high-level design, which means it signifies the procedure of the component-level design.</li>
  <li>LLD is also called details or micro-level design.</li>
  <li>Designer and developer prepare the Low-Level Design.</li>
  <li>It is developed after High-level design.</li>
  <li>It is used by designers, operation teams, and implementers.</li>
  <li></li>
</ul>

<hr />
<h1>Requirement and Specification</h1>
<h2>Requirement</h2>
<ul>
  <li>They plan the software from the end-user, business, and stakeholder perspectives.</li>
  <li>The requirements define what the software must do.</li>
  <li>Some of the common terminologies used for requirement document are as follows:
           SRD: System Requirement Document
           BRD: Business Requirement Document</li>
</ul>

<h2>Specification</h2>
<ul>
  <li>They prepare the software from the technical team's point of view.</li>
  <li>The specification defines how the software will be developed.</li>
  <li>Some of the common terminologies used for specification document are as follows:
FRS: Functional Requirement Specifications
SRS: System Requirement Specifications
CRS: Configurations Requirements Specification
PRS: Performance Requirements Specifications
RRS: Reliability Requirements Specifications
CRS: Compatibility Requirements Specifications
</li>
</ul>

<hr />
<h1>BRS and SRS</h1>
<p>n software testing, BRS and SRS types of document requirements depend upon business type, their standards, how company processes, and what class of software is to be developed.</p>
<h2>BRS</h2>
<p>The BRS document stands for Business Requirement Specification. To create the BRS document, the Business analyst will interrelate with the customers. The BRS document includes the business rules, the project's scope, and in-detail client's requirements.In this type of document, the client describes how their business works or the software they need.</p>

<h2>SRS</h2>
<p>
The SRS document stands for Software Requirement Specification.In this document, the Business Analyst will collect the Customer Requirement Specifications (CRS) from the client and translate them into Software Requirement Specification (SRS). The SRS contains how the software should be developed and given by the Business Analyst (BA). In other words, we can say that the SRS document is used to covert the customer information into a detailed document, which can easily understand by the developers and the test engineers.The SRS document is used to determine the early cost of the software product.</p>

<hr />

<h1>SDLC</h1>
<p>SDLC is a process that creates a structure of development of software. There are different phases within SDLC, and each phase has its various activities. It makes the development team able to design, create, and deliver a high-quality product.SDLC describes various phases of software development and the order of execution of phases. Each phase requires deliverable from the previous phase in a life cycle of software development. Requirements are translated into design, design into development and development into testing; after testing, it is given to the client.</p>
<ul>
  <li>Requirement Phase</li>
  <li>Design Phase</li>
  <li>Build/Development Phase</li>
  <li>Testing Phase</li>
  <li>Deployment Phase</li>
  <li>Maintenance</li>
</ul>

<h2>Requirement Phase</h2>
<p>This is the most crucial phase of the software development life cycle for the developing team as well as for the project manager. During this phase, the client states requirements, specifications, expectations, and any other special requirement related to the product or software. All these are gathered by the business manager or project manager or analyst of the service providing company.The requirement includes how the product will be used and who will use the product to determine the load of operations. All information gathered from this phase is critical to developing the product as per the customer requirements.</p>

<h2>Design Phase</h2>
<p>The design phase includes a detailed analysis of new software according to the requirement phase. This is the high priority phase in the development life cycle of a system because the logical designing of the system is converted into physical designing. The output of the requirement phase is a collection of things that are required, and the design phase gives the way to accomplish these requirements. The decision of all required essential tools such as programming language like Java, .NET, PHP, a database like Oracle, MySQL, a combination of hardware and software to provide a platform on which software can run without any problem is taken in this phase.There are several techniques and tools, such as data flow diagrams, flowcharts, decision tables, and decision trees, Data dictionary, and the structured dictionary are used for describing the system design.</p>

<h2>Build/Development Phase</h2>
<p>After the successful completion of the requirement and design phase, the next step is to implement the design into the development of a software system. In this phase, work is divided into small units, and coding starts by the team of developers according to the design discussed in the previous phase and according to the requirements of the client discussed in requirement phase to produce the desired result.Front-end developers develop easy and attractive GUI and necessary interfaces to interact with back-end operations and back-end developers do back-end coding according to the required operations. All is done according to the procedure and guidelines demonstrated by the project manager.</p>

<h2>Testing Phase</h2>
<p>Testing is the last step of completing a software system. In this phase, after getting the developed GUI and back-end combination, it is tested against the requirements stated in the requirement phase. Testing determines whether the software is actually giving the result as per the requirements addressed in the requirement phase or not. The Development team makes a test plan to start the test. This test plan includes all types of essential testing such as integration testing, unit testing, acceptance testing, and system testing. Non-functional testing is also done in this phase.If there are any defects in the software or it is not working as per expectations, then the testing team gives information to the development team in detail about the issue. If it is a valid defect or worth to sort out, it will be fixed, and the development team replaces it with the new one, and it also needs to be verified.</p>

<h2>Deployement Phase</h2>
<p>When software testing is completed with a satisfying result, and there are no remaining issues in the working of the software, it is delivered to the customer for their use.As soon as customers receive the product, they are recommended first to do the beta testing. In beta testing, customer can require any changes which are not present in the software but mentioned in the requirement document or any other GUI changes to make it more user-friendly. Besides this, if any type of defect is encountered while a customer using the software; it will be informed to the development team of that particular software to sort out the problem. If it is a severe issue, then the development team solves it in a short time; otherwise, if it is less severe, then it will wait for the next version.After the solution of all types of bugs and changes, the software finally deployed to the end-user.</p>

<h2>Maintenance</h2>
<p>The maintenance phase is the last and long-lasting phase of SDLC because it is the process which continues until the software's life cycle comes to an end. When a customer starts using software, then actual problems start to occur, and at that time there's a need to solve these problems. This phase also includes making changes in hardware and software to maintain its operational effectiveness like to improve its performance, enhance security features and according to customer's requirements with upcoming time. This process to take care of product time to time is called maintenance.</p>

<hr />

<h1>WaterFall Model</h1>
<p>It is the first approach and the basic model used in software development. It is a simple model that is easy to use as well as understand. The execution happens in the sequence order, which means that the outcome of the one-stage is equal to the input of another stage. That's why it is also known as the Linear-sequential life cycle model.To avoid the overlapping issues of the multiple phases, every stage should be completed before moving to the next stage. Each stage of the waterfall model involves the deliverable of the previous stage, like requirements, are transferred to the design phase, design moved to development, and so on. When we have the Life critical (hospital application) and Machine critical (Military project), we will widely use the waterfall model.</p>
<ul>
  <li>Requirement collection</li>
<li>Feasibility study</li>
<li>Design</li>
  <li>Coding</li>
  <li>Testing</li>
  <li>Installation</li>
  <li>Maintenance</li>
</ul>

<hr />

<h1>Spiral Model</h1>
<p>The biggest problem we face in the waterfall model is that taking a long duration to complete the product, and the software became outdated. To solve this problem, we have a new approach, which is known as the Spiral model. The spiral model is also known as the cyclic model.In this model, we create the application module by module and handed over to the customer so that they can start using the application at a very early stage. And we prepare this model only when the module is dependent on each other. In this model, we develop the application in the stages because sometimes the client gives the requirements in between the process.</p>

<ul>
  <li>Requirement analysis
</li>
  <li>Design</li>
  <li>Coding</li>
  <li>Testing and risk analysis</li>
</ul>

<hr />

<h1>Prototype Model</h1>
<p>The most significant disadvantage of previous models (waterfall and spiral) is that there were lots of customer rejection that happens after the application was developed, and there was no involvement of the customers in between the project.

Hence, they started the new approach, which is known as the prototype model. In this, we will collect the requirements from the customer and prepare a prototype (sample), and get it reviewed and approved by the customer. And only when they satisfied, we will start working on the original projects so that there won't be any customer rejection.

The prototype is just the sample or a dummy of the required software product. If all the mentioned modules are present, then only the developer and tester will perform prototype testing.</p>

<h2>When we use the Prototype model</h2>
<p>Whenever the customer is new to the software industry or when he doesn't know how to give the requirements to the company.
When the developers are new to the domain.</p>

<h2>Prototype model process</h2>
<ul>
  <li>Requirement analysis</li>
  <li>feasibility study</li>
  <li>Create a prototype</li>
  <li>Prototype testing</li>
  <li>Customer review and approval</li>
  <li>Design</li>
  <li>Coding</li>
  <li>Testing</li>
  <li>Installation and maintenance</li>
</ul>


<hr />

<h1>V Model</h1>
<p>This model came up to overcome the drawback of the waterfall model. In this model, testing starts from the requirement stage itself.

In this model, first, all the activities go in a downward direction, and at one point in time, they start moving in the upward direction to re-use the test document for the testing process and form a V shape. Hence it is known as the V model.</p>

<hr />

<h1>Software Testing Life Cycle (STLC)</h1>
<p>The procedure of software testing is also known as STLC (Software Testing Life Cycle) which includes phases of the testing process. The testing process is executed in a well-planned and systematic manner. All activities are done to improve the quality of the software product.</p>

<h4>Software testing life cycle contains the following steps:</h4>
<ul>
  <li>Requirement Analysis</li>
  <li>Test Plan Creation</li>
  <li>Environment setup</li>
  <li>Test case Execution</li>
  <li>Defect Logging</li>
  <li>Test Cycle Closure</li>
</ul>

<h2>Requirement Analysis</h2>
<p>The first step of the manual testing procedure is requirement analysis. In this phase, tester analyses requirement document of SDLC (Software Development Life Cycle) to examine requirements stated by the client. After examining the requirements, the tester makes a test plan to check whether the software is meeting the requirements or not.</p>

<h2>Test Plan Creation:</h2>
<p>Test plan creation is the crucial phase of STLC where all the testing strategies are defined. Tester determines the estimated effort and cost of the entire project. This phase takes place after the successful completion of the Requirement Analysis Phase. Testing strategy and effort estimation documents provided by this phase. Test case execution can be started after the successful completion of Test Plan Creation.</p>

<h2>Environment setup</h2>
<p>Setup of the test environment is an independent activity and can be started along with Test Case Development. This is an essential part of the manual testing procedure as without environment testing is not possible. Environment setup requires a group of essential software and hardware to create a test environment. The testing team is not involved in setting up the testing environment, its senior developers who create it.</p>

<h2>Test case Execution</h2>
<p>Test case Execution takes place after the successful completion of test planning. In this phase, the testing team starts case development and execution activity. The testing team writes down the detailed test cases, also prepares the test data if required. The prepared test cases are reviewed by peer members of the team or Quality Assurance leader.

RTM (Requirement Traceability Matrix) is also prepared in this phase. Requirement Traceability Matrix is industry level format, used for tracking requirements. Each test case is mapped with the requirement specification. Backward & forward traceability can be done via RTM</p>

<h2>Defect Logging</h2>
<p>his phase determines the characteristics and drawbacks of the software. Test cases and bug reports are analyzed in depth to detect the type of defect and its severity.

Defect logging analysis mainly works to find out defect distribution depending upon severity and types.If any defect is detected, then the software is returned to the development team to fix the defect, then the software is re-tested on all aspects of the testing.</p>

<h2>Test Cycle Closure</h2>
<p>The test cycle closure report includes all the documentation related to software design, development, testing results, and defect reports.

This phase evaluates the strategy of development, testing procedure, possible defects in order to use these practices in the future if there is a software with the same specification.</p>

<hr />

<h1>Types of Software Testing</h1>

<img src="https://static.javatpoint.com/tutorial/software-testing/images/types-of-software-testing.png" alt="Girl in a jacket" width="500" height="600">


<h2>Manual Testing</h2>
<p>Testing any software or an application according to the client's needs without using any automation tool is known as manual testing.

In other words, we can say that it is a procedure of verification and validation. Manual testing is used to verify the behavior of an application or software in contradiction of requirements specification.</p>

<ul>
  <li>White Box Testing</li>
  <li>Black Box Testing</li>
  <li>Grey Box Testing</li>
</ul>

<h3>White Box Testing</h3>
<p>In white-box testing, the developer will inspect every line of code before handing it over to the testing team or the concerned test engineers.In white-box testing, the developer will inspect every line of code before handing it over to the testing team or the concerned test engineers.White box testing is also known as open box testing, glass box testing, structural testing, clear box testing, and transparent box testing.</p>

<h3>Black Box Testing</h3>
<p>Another type of manual testing is black-box testing. In this testing, the test engineer will analyze the software against requirements, identify the defects or bug, and sends it back to the development team.Then, the developers will fix those defects, do one round of White box testing, and send it to the testing team.Here, fixing the bugs means the defect is resolved, and the particular feature is working according to the given requirement.In other words, we can say that black box testing is a process of checking the functionality of an application as per the customer requirement. The source code is not visible in this testing; that's why it is known as black-box testing.</p>

<ul>
  <li>Functional Testing</li>
  <li>Non-function Testing</li>
</ul>

<h4>Functional Testing</h4>
<p>The test engineer will check all the components systematically against requirement specifications is known as functional testing. Functional testing is also known as Component testing.

In functional testing, all the components are tested by giving the value, defining the output, and validating the actual output with the expected value.</p>

<ul>
  <li>Unit Testing</li>
  <li>Integration Testing</li>
  <li>System Testing</li>
</ul>

<h4>Unit Testing</h4>
<p>Unit testing is the first level of functional testing in order to test any software. In this, the test engineer will test the module of an application independently or test all the module functionality is called unit testing.The primary objective of executing the unit testing is to confirm the unit components with their performance. Here, a unit is defined as a single testable function of a software or an application. And it is verified throughout the specified application development phase.</p>

<h4>Integration Testing</h4>
<p>Once we are successfully implementing the unit testing, we will go integration testing. It is the second level of functional testing, where we test the data flow between dependent modules or interface between two features is called integration testing.The purpose of executing the integration testing is to test the statement's accuracy between each module.</p>

<p>Integration testing is also further divided into the following parts:</p>
<ul>
  <li>Incremental Testing</li>
  <li>Non-Incremental Testing</li>
</ul>

<h4>Incremental Testing</h4>
<p>Whenever there is a clear relationship between modules, we go for incremental integration testing. Suppose, we take two modules and analysis the data flow between them if they are working fine or not.

If these modules are working fine, then we can add one more module and test again. And we can continue with the same process to get better results.</p>

<h4>Non incremental Testing</h4>
<p>Whenever the data flow is complex and very difficult to classify a parent and a child, we will go for the non-incremental integration approach. The non-incremental method is also known as the Big Bang method.</p>


<h4>System Testing</h4>
<p>Whenever we are done with the unit and integration testing, we can proceed with the system testing.

In system testing, the test environment is parallel to the production environment. It is also known as end-to-end testing.

In this type of testing, we will undergo each attribute of the software and test if the end feature works according to the business requirement. And analysis the software product as a complete system.</p>


<h4>Non-Functional Testing</h4>
<p>The next part of black-box testing is non-functional testing. It provides detailed information on software product performance and used technologies.

Non-functional testing will help us minimize the risk of production and related costs of the software.

Non-functional testing is a combination of performance, load, stress, usability and, compatibility testing.</p>

<p>Types of Non Functional Testing</p>
<ul>
  <li>Performance Testing</li>
  <li>Usability Testing</li>
  <li>Compatibility Testing</li>
</ul>

<h4>Performance Testing</h4>
<p>In performance testing, the test engineer will test the working of an application by applying some load.

In this type of non-functional testing, the test engineer will only focus on several aspects, such as Response time, Load, scalability, and Stability of the software or an application.</p>

<p>Classification of Performance Testing</p>

<ul>
  <li>Load Testing</li>
  <li>Stress Testing</li>
  <li>Scalability Testing</li>
  <li>Stability Testing</li>
</ul>

<h4>Load Testing</h4>
<p>While executing the performance testing, we will apply some load on the particular application to check the application's performance, known as load testing. Here, the load could be less than or equal to the desired load.

It will help us to detect the highest operating volume of the software and bottlenecks.
Here, load means that when N-number of users using the application simultaneously or sending the request to the server at a time.

Load testing will help to detect the maximum operating capacity of an application and any blockages or bottlenecks.The load testing is mainly used to test the Client/Server's performance and applications that are web-based.</p>



<h4>Stress Testing</h4>
<p>It is used to analyze the user-friendliness and robustness of the software beyond the common functional limits. Primarily, stress testing is used for critical software, but it can also be used for all types of software applications.</p>

<h4>Scalability Testing</h4>
<p>It is used to check an application's performance by increasing or decreasing the load in particular scales known as scalability testing. It is executed at a hardware, software, or database level.</p>

<h4>Stability Testing</h4>
<p>Stability testing is a procedure where we evaluate the application's performance by applying the load for a precise time.

It mainly checks the constancy problems of the application and the efficiency of a developed product. In this type of testing, we can rapidly find the system's defect even in a stressful situation.</p>



<h4>Usability Testing</h4>
<p>Another type of non-functional testing is usability testing. In usability testing, we will analyze the user-friendliness of an application and detect the bugs in the software's end-user interface.

Here, the term user-friendliness defines the following aspects of an application:

The application should be easy to understand, which means that all the features must be visible to end-users.
The application's look and feel should be good that means the application should be pleasant looking and make a feel to the end-user to use it.</p>

<p>In Usability Testing, the user-friendliness can be described with the help of the following characteristics:</p>

 - Easy to understand
 - Easy to access
 - Look and feel
 - Faster to Access
 - Effective Navigation
 - Good Error Handling

<h4>Compatibility Testing</h4>
<p>In compatibility testing, we will check the functionality of an application in specific hardware and software environments. Once the application is functionally stable then only, we go for compatibility testing.

Here, software means we can test the application on the different operating systems and other browsers, and hardware means we can test the application on different sizes.</p>



<h3>Grey Box Testing</h3>
<p>Another part of manual testing is Grey box testing. It is a collaboration of black box and white box testing.

Since, the grey box testing includes access to internal coding for designing test cases. Grey box testing is performed by a person who knows coding as well as testing.In other words, we can say that if a single-person team done both white box and black-box testing, it is considered grey box testing.</p>

<h2>Automation Testing</h2>
<p>The most significant part of Software testing is Automation testing. It uses specific tools to automate manual design test cases without any human interference.

Automation testing is the best way to enhance the efficiency, productivity, and coverage of Software testing.

It is used to re-run the test scenarios, which were executed manually, quickly, and repeatedly.</p>

<hr />

<h1>User Acceptance Testing</h1>
<p>User acceptance testing (UAT) is a type of testing, which is done by the customer before accepting the final product. Generally, UAT is done by the customer (domain expert) for their satisfaction, and check whether the application is working according to given business scenarios, real-time scenarios.In this, we concentrate only on those features and scenarios which are regularly used by the customer or mostly user scenarios for the business or those scenarios which are used daily by the end-user or the customer.However, the software has passed through three testing levels (Unit Testing, Integration Testing, System Testing) But still there are some minor errors which can be identified when the system is used by the end user in the actual scenario.</p>


<hr />
<h1>Bug Life Cycle</h1>
<img src:"https://static.javatpoint.com/tutorial/software-testing/images/bug-life-cycle.png">







  













